package com.example.book.service.model;

import com.example.book.service.model.enums.OrderStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents a customer's order in the book store.
 * <p>
 * An Order serves as a container for a collection of {@link BookItem}s that a
 * {@link Client} wishes to purchase. It tracks the total price, the date of creation,
 * and the current status of the order throughout its lifecycle (e.g., DRAFT, SUBMITTED).
 * This entity is central to the application's e-commerce functionality.
 *
 * @see Client
 * @see BookItem
 * @see OrderStatus
 */
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Order {

    /**
     * The unique identifier for the order.
     * Automatically generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The exact date and time when the order was created.
     * This is typically set when the client adds the first item to their cart.
     */
    @NotNull(message = "Order date cannot be null")
    @Column(name = "order_date", nullable = false)
    private LocalDateTime orderDate;

    /**
     * The total calculated price for all items in the order.
     * This value should be updated whenever items are added, removed, or their quantities change.
     */
    @NotNull(message = "Total price cannot be null")
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    /**
     * The client who owns this order.
     * This is a many-to-one relationship, as one client can have multiple orders.
     * Fetched lazily to optimize performance.
     */
    @NotNull(message = "Client must be associated with an order")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "client_id", nullable = false)
    @ToString.Exclude // Excluded to prevent recursion in logs
    @EqualsAndHashCode.Exclude // Excluded as ID is sufficient for equality checks
    private Client client;

    /**
     * A list of all book items included in this order.
     * This is a one-to-many relationship, as one order can contain multiple book items.
     * <p>
     * {@code cascade = CascadeType.ALL}: Ensures that any changes to the order (like saving or deleting)
     * are propagated to its associated book items.
     * <p>
     * {@code orphanRemoval = true}: Guarantees that if a {@link BookItem} is removed from this list,
     * it is automatically deleted from the database, preventing orphaned records.
     * <p>
     * Fetched lazily to avoid loading all items when only the order header is needed.
     */
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Builder.Default
    private List<BookItem> bookItems = new ArrayList<>();

    /**
     * The current status of the order, representing its stage in the business process.
     * For example, a new shopping cart starts as a {@code DRAFT}.
     * Defaults to {@link OrderStatus#DRAFT}.
     *
     * @see OrderStatus
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private OrderStatus status = OrderStatus.DRAFT;

    /**
     * Compares two Order objects for equality.
     * Two orders are considered equal if they have the same ID.
     *
     * @param o the object to compare against.
     * @return {@code true} if the IDs are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Order)) return false;
        Order order = (Order) o;
        return Objects.equals(id, order.id);
    }

    /**
     * Generates a hash code for the Order based on its ID.
     *
     * @return the hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}